:PROPERTIES:
:ID:       62380240-2804-497b-b806-8a849dbdecd0
:END:
#+title: Rust types

- one of their most fundamental roles of types is to hint how to interpret bits of memory
* alignment
- byte-aligned: to be placed at an address that is a multiple of 8 bits
- describes where the bytes for a type can be stored
- the hardware constrains where a given type can be placed
  - for example: pointers point to bytes, not bits
  - if you placed a value of type T starting at bit 4 of your computer’s memory, you would have no way to refer to its location; you can create a pointer pointing only to byte 0 or byte 1 (bit 8). For this reason, all values, no matter their type, must start at a byte boundary.
  - Some values have more stringent alignment rules than just being byte-aligned. In the CPU and the memory system, memory is often accessed in blocks larger than a single byte. For example, on a 64-bit CPU, most values are accessed in chunks of 8 bytes (64 bits), with each operation starting at an 8-byte-aligned address. This is referred to as the CPU’s word size.
* layout
- an in-memory representation of a type
** C-compatible layout
- place all fields in the same order that they appear in the original struct definition
- deterministic field ordering for types that happen to have the same fields
#+begin_src rust
#[repr(C)]
struct Foo {
  tiny: bool,
  normal: u32,
  small: u8,
  long: u64,
  short: u16,
}
#+end_src
|------------------+-----------+-------------------------------------|
| 8-byte alligment | bit count | values (0 = padding)                |
|------------------+-----------+-------------------------------------|
|                1 |   000-032 | tinytiny 00000000 00000000 00000000 |
|                2 |   033-064 | normnorm normnorm normnorm normnorm |
|                3 |   065-096 | smalsmal 00000000 00000000 00000000 |
|                4 |   097-128 | 00000000 00000000 00000000 00000000 |
|                5 |   129-160 | longlong longlong longlong longlong |
|                6 |   161-192 | longlong longlong longlong longlong |
|                7 |   193-224 | shorshor shorshor 00000000 00000000 |
|------------------+-----------+-------------------------------------|
** Rust layout with =#[repr(Rust)]=
- fields can be reordered
- even two different types that share all the same fields, of the same type, in the same order, are not guaranteed to be laid out the same when using the default Rust layout
(below is an example, however it may or may not be compatible with what the compiler would acctually produce)
|------------------+-----------+-------------------------------------|
| 8-byte alligment | bit count | values (0 = padding)                |
|------------------+-----------+-------------------------------------|
|                1 |   000-032 | tinytiny smalsmal shorshor shorshor |
|                2 |   033-064 | normnorm normnorm normnorm normnorm |
|                3 |   065-096 | longlong longlong longlong longlong |
|                4 |   097-128 | longlong longlong longlong longlong |
|------------------+-----------+-------------------------------------|
** packed layout with =#[repr(packed)]=
- reduces the in-memory size, but also the performance
- useful for memory-cnstrained devices
|------------------+-----------+-------------------------------------|
| 8-byte alligment | bit count | values (X = next value)             |
|------------------+-----------+-------------------------------------|
|                1 |   000-032 | Tsmalsma lshorsho rshorsho rnormnor |
|                2 |   033-064 | mnormnor mnormnor mnormnor mlonglon |
|                3 |   065-096 | glonglon glonglog glonglog glonglog |
|                4 |   097-128 | glonglog glonglog glonglog gXXXXXXX |
|------------------+-----------+-------------------------------------|
** custom aligned layout with =#[repr(align(n))]=
- gives a particular field or type a larger alignment than it technically requires
- common use case for this is to ensure that different values stored contiguously in memory (like in an array) end up in different cache lines on the CPU, this avoids false sharing, which can cause huge performance degradations in concurrent programs
  - false sharing occurs when two different CPUs access different values that happen to share a cache line; while they can theoretically operate in parallel, they both end up contending to update the same single entry in the cache
** complex types
- =Tuple= - represented like a struct with fields of the same type as the tuple values in the same order
- =Array= - represented as a contiguous sequence of the contained type with no padding between the elements
- =Union= - layout is chosen independently for each variant. alignment is the maximum across all the variants
- =Enum= - same as union, but with one additional hidden shared field that stores the enum variant discriminant. the discriminant is the value thecode uses to determine which of the enum variants a given value holds. the size of the discriminant field depends on the number of variants

* dynamically sized types (DST) and
- most types in Rust implement Sized automatically
  - that is, they have a size that’s known at compile time
- two common types do not: trait objects and slices
  - a dyn Iterator or a [u8], do not have a well-defined size
  - their size depends on some information that is known only when the program runs and not at compile time, which is why they are called dynamically sized types
- often the compiler must know the size of something in order to produce valid code, such as how much space to allocate to a tuple of type (i32, dyn Iterator, [u8], i32) or what offset to use if your code tries to access the fourth field
- the compiler requires types to be Sized nearly everywhere.
  - struct fields, function arguments, return values, variable types, and array types must all be Sized
  - explicitly opt out with =T: ?Sized= (the ? means “may not be”)
** wide pointers
- to make a function able to accept trait object or slice as argument (DST) (to bridge this gap between unsized and sized types), is to place unsized types behind a wide pointer (also known as a fat pointer)
  - a wide pointer is just like a normal pointer, but it includes an extra word-sized field that gives the additional information about that pointer that the compiler needs to generate reasonable code for working with the pointer
    - wide pointer is Sized - it is twice the size of a usize (the size of a word on the target platform): one usize for holding the pointer, and one usize for holding the extra information needed to “complete” the type
    - when taking reference to a DST, the compiler automatically constructs a wide pointer
      - for a slice, the extra information is simply the length of the slice
      - for a trait object ...
  - =Box= and =Arc= also support storing wide pointers, which is why they both support =T: ?Sized=
* compilation and dispatch
- [[id:1d75277b-af26-4a7f-969b-a8357a5be931][method dispatch]] describes how a language or environment will select which implementation of a method or function to use
when choosing between static and dynamic dispatch, there is rarely a clear-cut right answer, however, broadly speaking, static dispatch should be utilized in libraries and dynamic dispatch in binaries
|----------+------------------------------+-------------------------------|
| dispatch | library                      | binary                        |
|----------+------------------------------+-------------------------------|
| static   | users of libarary can choose | slower compilation time,      |
|          | whether they want to use     | marinally better performance, |
|          | static or dynamic dispatch   | more convoluted               |
|----------+------------------------------+-------------------------------|
| dynamic  | users are forced to follow   | cleaner code,                 |
|          | library implementation       | quicker compilation time,     |
|          |                              | smaller binary size           |
|----------+------------------------------+-------------------------------|
** static dispatch
#+begin_src rust
impl String {
  pub fn contains(&self, p: impl Pattern) -> bool {
    p.is_contained_in(self)
  }
}
#+end_src
- when a type or function that is generic over T, compiler makes a copy of that type or function for each type T
  - the compiler does only copy parts of the code that are used
- =impl Trait= is shorthand for =<T: Trait>=
- for any given copy of the method, the address we are “dispatching to” is known statically.
*** monomorphization
- a process of converting code with generic types into many non-generic types
- it’s part of the reason generic Rust code usually performs just as well as non-generic code
- monomorphization can increase compile time and can make the program larger
*** optimizations
- each instance is optimized separately and with all of the types known. As a result, the code is just as efficient as if the trait method of the pattern that is passed in were called directly without any traits present
- compiler has full knowledge of the types involved and can even inline the implementation called method
*** drawbacks
- because instructions aren’t shared between different instantiations of a generic type’s methods, the CPU’s instruction cache is less effective as it now needs to hold multiple copies of effectively the same instructions
** dynamic dispatch
#+begin_src rust
impl String {
  pub fn contains(&self, p: &dyn Pattern) -> bool {
    p.is_contained_in(&*self)
  }
}
#+end_src
- enables code to call a trait method on a generic type without knowing what that type is
- reduces compile times, since it’s no longer necessary to compile multiple copies of types and methods
- can improve the efficiency of CPU instruction cache
- prevents the compiler from optimizing for the specific types that are used
  - with dynamic dispatch, all the compiler can do is insert a call to the function through the vtable
  - it can no longer perform any additional optimizations as it does not know what code will sit on the other side of that function call
  - every method call on a trait object requires a lookup in the vtable, which adds a small amount of overhead over calling the method directly
- the caller gives a pointer to a chunk of memory called a virtual method table, or vtable,
- allows to use the same function body regardless of what type the caller wants to use

- use the =&dyn= keyword to opt-in to dynamic dispatch
  - the reason to use =&=: compiler at compile time doesn't know the size of the pattern type that the caller passes in, so it don’t know how much space to set aside for it
  - in other words, =dyn Trait= is =!Sized= (where the =!= means not)
  - to make possible to take it as argument, it has to be =Sized=
  - placing it behind a pointer (which size of is known) makes it =Sized=
  - since it also need to pass along the table of method addresses, this pointer becomes a wide pointer, where the extra word holds the pointer to the vtable
  - =&mut=, =Box=, =Arc= types are able to hold a wide pointer and therefor can be used for dynamic dispatch

*** vtable
- example of an explicit vtable: [[https://doc.rust-lang.org/std/task/struct.RawWakerVTable.html][std::task::RawWakerVTable]]
- holds the address of the implementation of all the trait’s methods for the type in question
- when the code inside the method wants to call a trait method on the provided pattern, it looks up the address of that pattern’s implementation of trait method in the vtable and then calls the function at that address
- every vtable also contains information about the concrete type’s layout and alignment since that information is always needed to work with a type
*** trait object
- the combination of a type that implements a trait and its vtable is known as a trait object
- non-object-safe traits cannot be turned into trait objects
- trait bound =Self: Sized= implies that Self is not being used through a trait object (since it would then be !Sized).
  - because methods with a =where Self: Sized= bound are exempted when checking if a trait is object-safe, that bound can be placed on:
    a. a trait to require that the trait never use dynamic dispatch, or you can place it on
    b. a specific method to make that method unavailable when the trait is accessed through a trait object.
*** object-safe
- to be object-safe,
  - none of a trait’s methods can be generic or use the Self type
  - the trait cannot have any static methods (that is, methods whose first argument does not dereference to Self), since it would be impossible to know which instance of the method to call
- examples of traits that are not object-safe
  - the Clone trait, whose clone method returns Self, cannot be turned into a trait object. If we accept a dyn Clone trait object and then call clone on it, the compiler won’t know what type to return.
  - the Extend trait from the standard library, which has a method extend that is generic over the type of the provided iterator (so there may be many instances of it). If you were to call a method that took a dyn Extend, there would be no single address for extend to place in the trait object’s vtable; there would have to be one entry for every type extend might ever be called with.

* generic traits
#+begin_src rust
trait Seq<T> {
    fn len(&self) -> u32;
    fn elt_at(&self, n: u32) -> T;
    fn iter<F>(&self, f: F) where F: Fn(T);
}
#+end_src
- the rule of thumb:
  - use an associated type if only one implementation of the trait for a given type is expected
  - use a generic type parameter otherwise

** generic type parameters
- =trait Foo<T>=
- users must always specify all the generic parameters and repeat any bounds on those parameters.
  - This can quickly get messy and hard to maintain.
  - If you add a generic parameter to a trait, all users of that trait must also be updated to reflect the change.
  - And since multiple implementations of a trait may exist for a given type, the compiler may have a hard time deciding which instance of the trait you meant to use, leading to awful disambiguating function calls like FromIterator::<u32>::from_iter.
- the upside is that you can implement the trait multiple times for the same type—for example, you can implement PartialEq against multiple right-hand side types for your type, or you can implement both FromIterator<T> and FromIterator<&T> where T: Clone, precisely because of the flexibility that generic traits provide.

** associated types
- =trait Foo { type Bar; }=
- associated types are often significantly easier to work with,
- won't allow multiple implementations
- the compiler needs to know only the type that implements the trait, and all the associated types follow (since there is only one implementation).
- This means the bounds can all live in the trait itself and do not need to be repeated on use.
- In turn, this allows the trait to add further associated types without affecting its users.
- And because the type dictates all the associated types of the trait, you never have to disambiguate with the unified function calling syntax shown in the previous paragraph.
- However, you cannot implement Deref against multiple Target types, nor can you implement Iterator with multiple different Item types.
*** COMMENT example
#+begin_src jupyter-rust :session xxx :exports both
trait Foo { type Bar; }
#[derive(Debug)]
struct X ;
impl Foo for X { type Bar = String; }
let x = X {};
x
#+end_src

#+RESULTS:
: X

* coherence and the orphan rule
- coherence property: for any given type and method, there is only ever one correct choice for which implementation of the method to use for that type
- orphan rule: you can implement a trait for a type only if the trait or the type is local to your crate

  - blanket implementations
    - allows to implement traits over a range of types with code like impl<T> MyTrait for T where T: and so on.
    - not limited to just one particular type but instead applies to a wide range of types.
    - only the crate that defines a trait is allowed to write a blanket implementation - adding a blanket implementation to an existing trait is considered a breaking change

  - fundamental types
    - types marked with the =#[fundamental]= attribute (=&=, =&mut=, =Box=, =Pin=)
    - some types are so essential that it’s necessary to allow anyone to implement traits on them, even if this seemingly violates the orphan rule
    - adding a blanket implementation over a fundamental type is also considered a breaking change.

  - covered implementations
    - There are some limited cases where we want to allow implementing a foreign trait for a foreign type, which the orphan rule does not normally allow. The simplest example of this is when you want to write something like impl From<MyType> for Vec<i32>. Here, the From trait is foreign, as is the Vec type, yet there is no danger of violating coherence. This is because a conflicting implementation could be added only through a blanket implementation in the standard library (the standard library cannot otherwise name MyType), which is a breaking change anyway.

- [[https://doc.rust-lang.org/reference/items/implementations.html?highlight=orphan#orphan-rules][reference]]
- valid
#+begin_src rust
impl<T> From<T> for MyType
impl<T> From<T> for MyType<T>
impl<T> From<MyType> for Vec<T>
impl<T> ForeignTrait<MyType, T> for Vec<T>
impl<T> ForeignTrait<LocalType, T> for ForeignType
#+end_src
- invalid
#+begin_src rust
impl<T> ForeignTrait for T
impl<T> From<T> for T
impl<T> From<Vec<T>> for T
impl<T> From<MyType<T>> for T
impl<T> From<T> for Vec<T>
impl<T> ForeignTrait<T, MyType> for Vec<T>
impl<T> ForeignTrait<T, LocalType> for ForeignType
#+end_src

* trait bounds
- trait bounds do not have to be of the form T: Trait where T is some type your implementation or type is generic over. The bounds can be arbitrary type restrictions and do not even need to include generic parameters, types of arguments, or local types.
- generic type parameters do not need to appear only on the left-hand side =io::Error: From<MyError<T>>=
- if your method wants to construct a =HashMap<K, V, S>= whose keys are some generic type =T= and whose value is a =usize=, instead of writing the bounds out like
  =where T: Hash + Eq, S: BuildHasher + Default=, you could write
  =where HashMap<T, usize, S>: FromIterator=
  - [[https://doc.rust-lang.org/std/iter/trait.FromIterator.html#impl-FromIterator%3C(K%2C%20V)%3E-1][reference]]
** derive trait
- many =#[derive (Trait)]= expansions desugar into =impl Trait for Foo<T> where T: Trait=
  - if we try to derive Clone this way for Foo<T> and Foo contains an Arc<T>. Arc implements Clone regardless of whether T implements Clone, but due to the derived bounds, Foo will implement Clone only if T does
** bounds on associated types of types generic over
  - If a type Item has an associated type Assoc from a trait Trait, then <Item as Trait>::Assoc is a type that is an alias of the type specified in the associated type definition. Furthermore, if Item is a type parameter, then Item::Assoc can be used in type parameters.
*** COMMENT examples
#+begin_src jupyter-rust :session assoc1 :exports both
trait AssociatedType { type Assoc; type Aff; }
struct Struct;
#[derive(Debug)]
struct OtherStruct;
impl AssociatedType for Struct { type Assoc = OtherStruct; type Aff = String; }
impl OtherStruct {
    fn new() -> OtherStruct { OtherStruct }
}
println!("{:?}\n{:?}",
         <Struct as AssociatedType>::Assoc::new(),
         <Struct as AssociatedType>::Aff::new());
#+end_src

#+RESULTS:
: OtherStruct
: ""

**** ?
#+begin_src rust
impl Debug for AnyIterable
where for<'a> &'a Self: IntoIterator,
        for<'a> <&'a Self as IntoIterator>::Item: Debug {
    fn fmt(&self, f: &mut Formatter) -> Result<(), Error> {
        f.debug_list().entries(self).finish()
}}
#+end_src

* marker traits
- https://doc.rust-lang.org/std/marker/index.html
- indicate a property of the implementing type
- they have no methods or associated types and serve just to tell that a particular type can or cannot be used in a certain way
- example: =Send= - safe to send across thread boundaries
  - There is no call to send in code that requires that a type is Send. Instead, the code assumes that the given type is fine to use in a separate thread, and without marker traits the compiler would have no way of checking that assumption
- purpose: they allow you to write bounds that capture semantic requirements not directly expressed in the code.
* auto-traits
- the compiler automatically implements them for types unless the type contains something that does not implement the marker trait
- [[https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits][reference]] [[https://doc.rust-lang.org/nightly/unstable-book/language-features/auto-traits.html][nightly]]
* marker types
- unit types (like =struct MyMarker;=) that hold no data and have no methods.
- useful for marking a type as being in a particular state ([[id:72caa898-b8a5-4045-8eea-c1a9656514a1][typestate]])
- useful when you want to make it impossible for a user to misuse an API
* existential types
- type inference is much easier when you have at least some known points to start the inference from
- all functions marked as async fn or with a return type of impl Trait have an existential return type: the signature does not give the true type of the return value, just a hint that the function returns some type that implements some set of traits that the caller can rely on
- the caller can only rely on the return type implementing those traits, and nothing else
  - it isn’t strictly true that the caller relies on the return type and nothing else.
  - the compiler will also propagate auto-traits like Send and Sync through impl Trait in return position
- name origin: we are asserting that there exists some concrete type that matches the signature, and we leave it up to the compiler to find what that type is
- compiler will usually then go figure that out by applying type inference on the body of the function
- not all instances of impl Trait use existential types
  - if impl Trait is used in argument position for a function, it’s really just shorthand for an unnamed generic parameter to that function
  - =fn foo(s: impl ToString)= is only syntax sugar for =fn foo<S: ToString>(s: S)=
- useful when: implementing traits that have associated types
  1. imagine you’re implementing the IntoIterator trait
  2. it has an associated type IntoIter that holds the type of the iterator that the type in question can be turned into
  3. with existential types, you do not need to define a separate iterator type to use for IntoIter
  4. instead, you can give the associated type as impl =Iterator<Item = Self::Item>= and just write an expression inside the =fn into_iter(self)= that evaluates to an =Iterator=, such as by using maps and filters over some existing iterator type
- allow to perform zero-cost type erasure
  - instead of exporting helper types just because they appear in a public signature somewhere (iterators and futures are common examples of this) you can use existential types to hide the underlying concrete type
  - users of your interface are shown only the traits that the relevant type implements, while the concrete type is left as an implementation detail
  - not only does this simplify the interface, but it also enables you to change that implementation as you wish without breaking downstream code in the future
