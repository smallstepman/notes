:PROPERTIES:
:ID:       2b5f2b28-4a45-42e4-b009-9ca295f726c4
:ROAM_REFS: https://youtu.be/xcygqF5LVmM?t=342
:END:
#+title: Rust data types
#+filetags: rust

* data types
** string literal
:PROPERTIES:
:ID:       e425c79c-559d-4c87-9a69-d5100a75ad00
:END:
- an immutable reference to value hardcoded into the program
- its type is =&str=, a string slice pointing to specific point in binary
#+begin_src rust
let s = "hello";
#+end_src
** string type
:PROPERTIES:
:ID:       0f790e28-8793-4fd3-8b0f-7eab2fb30387
:END:
- allocated on the heap
- internal representation of a String is a str
#+begin_src rust
let s = String::from("hello");
s.push_str(", world!");
let len = String::from("Hola").len();
println!("{}", s);
#+end_src
** string slice
:PROPERTIES:
:ID:       d765cc94-e7fd-40e1-9dc6-56d8ce3348a1
:END:
a reference to a part of a =String=
#+begin_src rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
#+end_src
** hash map
:PROPERTIES:
:ID:       fcc983ad-e42b-4aa7-ad6c-58b3b1497811
:END:
- inserting already existing value overwrites it
#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];
let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();

let score = scores.get(&team_name); // -> Option<&V> or None

for (key, value) in &scores {
    println!("{}: {}", key, value);
}

// insert if doesn't exist
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);
#+end_src
** vectors
:PROPERTIES:
:ID:       431010cd-ed6b-4883-87f7-d1e67e7d8698
:END:
- can hold same type
- stored on heap
#+begin_src rust
let v: Vec<i32> = Vec::new();
v.push(5);
v.push(6);

let mut v = vec![1, 2, 3];

let third: &i32 = &v[2];

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}

for i in &v {
    println!("{}", i);
}

for i in &mut v {
    *i += 50;
}

enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
#+end_src

** array
:PROPERTIES:
:ID:       41a10dca-180b-45f2-bcf9-d19ca91884e3
:END:
- stored on stack
- can hold single type
#+begin_src rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5]; // == [3,3,3,3,3]
let first = a[0];
#+end_src
** function pointers
:PROPERTIES:
:ID:       a5e87543-0e84-4394-89f6-9aea33ac19a6
:END:
#+begin_src rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
#+end_src
** enum
:PROPERTIES:
:ID:       0ed94a24-09b5-48fd-9c73-652c2912d6ec
:END:
#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src
** struct
:PROPERTIES:
:ID:       c89fbd1c-e7fc-4b22-9bdd-a17b838ceff9
:END:
** unit struct
:PROPERTIES:
:ID:       8897d6d0-ae14-45d8-915e-11349efc8354
:END:
** tuple struct
:PROPERTIES:
:ID:       0f8fc274-8743-4c19-ae97-a687df0d6e11
:END:
** tuple
:PROPERTIES:
:ID:       1b12fe11-f3c2-47bd-9557-fbaf8c37d78d
:END:
** union
:PROPERTIES:
:ID:       0432654c-0098-4561-8c88-735cb992a8a7
:END:
