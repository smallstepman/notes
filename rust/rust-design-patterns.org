:PROPERTIES:
:ID:       1711a3a7-9746-45c5-a1c6-928377bd7a21
:END:
#+title: Rust design patterns

* newtype
- another useful representation is repr(transparent), which can be used only on types with a single field and which guarantees that the layout of the outer type is exactly the same as that of the inner type. This comes in handy in combination with the “newtype” pattern, where you may want to operate on the in-memory representations of some struct A and struct NewA(A) as if they were the same. Without repr(transparent), the Rust compiler does not guarantee that they will have the same layout.
* typestate
:PROPERTIES:
:ID:       72caa898-b8a5-4045-8eea-c1a9656514a1
:END:
* co-inductive reasoning
- http://rust-lang.github.io/chalk/book/recursive/coinduction.html
- https://www.youtube.com/watch?v=nOqO5OlC920
- https://github.com/rust-lang/rust/issues/26925
* COMMENT old example
#+begin_src rust
use std::ops::Deref;

struct DerefExample<T> {
    value: T
}

impl<T> Deref for DerefExample<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.value
    }
}

let x = DerefExample { value: 'a' };
assert_eq!('a', *x);
let y = DerefExample { value: 1 };
assert_eq!(1, *y);
#+end_src

#+begin_src rust
use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -> Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

assert_eq!(
    Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
    Point { x: 3, y: 3 }
);
#+end_src

#+begin_src rust
let v: Vec<bool> = x.iter().filter(|v| match v { true => false, false => true} ).cloned().collect();
let x: Vec<bool> = vec![true,false,false];
println!("{:?}", v);
#+end_src
