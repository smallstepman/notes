:PROPERTIES:
:ID:       2b5f2b28-4a45-42e4-b009-9ca295f726c4
:END:
#+title: Rust basics
#+filetags: :project:

* data types
** string literal
value is hardcoded into the program and it's immutable  (reference). Its type is =&str=, a string slice pointing to specific point in binary.
#+begin_src rust
let s = "hello";
#+end_src

** string type
allocated on the heap
#+begin_src rust
let s = String::from("hello");
s.push_str(", world!");
let len = String::from("Hola").len();
println!("{}", s);
#+end_src

** string slice
a reference to a part of a =String=

#+begin_src rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
#+end_src

** hash map
inserting already existing value overwrites it

#+begin_src rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let teams  = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];
let scores: HashMap<_, _> = teams.iter().zip(initial_scores.iter()).collect();

let score = scores.get(&team_name); // -> Option<&V> or None

for (key, value) in &scores {
    println!("{}: {}", key, value);
}

// insert if doesn't exist
scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);
#+end_src

** vectors
can hold same type, stored on heap

#+begin_src rust
let v: Vec<i32> = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);

let v = vec![1, 2, 3];

let third: &i32 = &v[2];

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}

v.push(6);

for i in &v {
    println!("{}", i);
}

let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}

enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}
let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
#+end_src

** arrays
stored on stack, can hold single type, immutable

#+begin_src rust
let a: [i32; 5] = [1, 2, 3, 4, 5];
let a = [3; 5]; // == [3,3,3,3,3]
let first = a[0];
#+end_src

** function pointers
#+begin_src rust
fn add_one(x: i32) -> i32 {
    x + 1
}

fn do_twice(f: fn(i32) -> i32, arg: i32) -> i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!("The answer is: {}", answer);
}
#+end_src

** enum

#+begin_src rust
fn main () {
    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
}

enum IpAddrKind {
    V4,
    V6,
}

fn route(ip_kind: IpAddrKind) { }

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from("127.0.0.1"),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from("::1"),
};
#+end_src

#+begin_src rust
enum IpAddr {
  V4(u8, u8, u8, u8),
  V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from("::1"));
#+end_src

#+begin_src rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
impl Message {
    fn call(&self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));
m.call();
#+end_src

#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}

let some_number = Some(5);
let some_string = Some("a string");
let absent_number: Option<i32> = None;
#+end_src

* Pattern matching
** irrefutable
patterns that will match for any possible value passed are irrefutable.
#+begin_src rust
let x = 5;
fn foo(a: i32) {}
for i in [1,2,3] {}
#+end_src
** refutable
patterns that can fail to match for some possible value are refutable
#+begin_src rust
let Some(x) = some_option
#+end_src
** =match=
*** =match= is exhaustive
- compiler confirms that all possible cases are handled.
#+begin_src rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
#+end_src
*** =_= pattern will match any value
#+begin_src rust
enum UsState {
    Alabama,
    Alaska,
}

enum Coin {
    Penny,
    Dime,
    Quarter(UsState),
    AlienCoin,
}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        },
        _ => 100,
    }
}
#+end_src
*** COMMENT example: ranges, patterns, advanced
#+begin_src rust
#[allow(dead_code)]
enum Zzz {
    One,
    Two,
    Num(u32),
}

struct Point {
    x: (i32,i32),
    y: i32,
}

fn foo() -> u32 {6}

#[allow(unused_mut, unreachable_patterns, unused_variables)]
fn main() {
    match foo() {
        n @ 1 => println!("1. {}", n),
        n @ 2 | n @ 3 | n @ 4 => println!("2. {}", n),
        n @ 5..=10 => println!("3. {}", n),
        _ => println!("4."),

    }

    let z: Option<i32> = None;
    let z: Option<i32> = Some(5);
    let b = true;
    if let Some(m) = z {
        println!("{}", m);
    } else if b {
        println!("haba");
    }
    else {
        println!("aSD");
    }

    // ----
    let a = Zzz::One;
    let a = Zzz::Num(100);
    if let Zzz::One = a {
        println!("a is One")
    } else if let Zzz::Num(v @ 100) = a {
        println!("100 for sure, {} see?", v)
    } else if let Zzz::Num(v) = a {
        println!("value v = {}", v)
    } else {
        println!("nada")
    }
    // ----

    let p = Point {x:(3,3), y:2};
    let q = true;
    match p {
        Point { x: (1, b), y } => println!("x = {:?}, y = {}", b, y),
        Point { y: 2, x: i } if q == false => println!("x = {:?}", i),
        Point { y: 2, x: i } if i.0 == i.1 => println!("true, x = {:?}", i),
        Point { y, .. } => println!("y = {}", y),
        _ => println!("nada")
    }
    // ----

    let mut setting_value = Some(5);
    let mut setting_value = None;
    let new_setting_value = Some(10);
    match (setting_value, new_setting_value) {
        (Some(_), Some(_)) => {
            println!("Can't overwrite an existing customized value");
        }
        _ => {
            setting_value = new_setting_value;
            println!("setting is {:?}", setting_value);
        }
    }
    // ----

    let numbers = (1,2,3,4,5);
    match numbers {
        (first, .., last) if first == 22 => println!("{} {}", first, last),
        (_, second, _, fourth, _) => println!("{} {}", second, fourth),
        (_, second, ..) => println!("{}", second),
    }
    // ----

    let mut count = Some(0);
    while let Some(i) = count {
        if i < 10 {
            count = Some(i+1)
        } else {
            println!("goodbye");
            break;
        }
    }
}
#+end_src

* Generics
abstract stand-ins for concrete types or other properties

** how to read =fn foo<T>(list: &[T]) -> T {}=
function =foo= is generic over some type =T=. This function has one parameter named =list= which is a slice of values of type T. The =foo= function will return a value of the same type =T=
** performance of *static dispatch*
Code doesn't run any slower using generic types than it would with concrete types. This is done thanks to monomorphization, which is the process of turning generic code into specific code by filling in the concrete types that are used when compiled.
** in =struct= definition

#+begin_src rust
struct Point<T> {
    x: T,
    y: T,
}

struct MixedPoint<T, U> {
    x: T,
    y: U,
}

impl<T, U> MixedPoint<T, U> {
    fn mixup<V, W>(self, other: MixedPoint<V, W>) -> MixedPoint<T, W> {
        MixedPoint {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
    let int_and_float = MixedPoint { x: 1, y: 2.0 };
    let str_and_char = MixedPoint { x: "Hello", y: 'c' };
    let mixup_point = int_and_float.mixup(str_and_char);
    println!("mp.x = {}, mp.y = {}", mixup_point.x, mixup_point.y); //OUT: "mp.x = 1, mp.y = 'c'",
}
#+end_src

** in =enum= definition

#+begin_src rust
enum Option<T> {
    Some(T),
    None,
}
enum Result<T, E> {
    Ok(T),
    Err(E),
}
#+end_src


* Ownership, References and Borrowing
  :PROPERTIES:
  :CUSTOM_ID: ch04---ownership-references-and-borrowing
  :END:

** taking =ownership=

  #+begin_src rust
  #+end_src

** =borrowiwng immutably=

  #+begin_src rust
  #+end_src

** =borrowiwng mutably=

  #+begin_src rust
  #+end_src
** Stack
- values are stored in order they were put into it and removed in the opposite order (last in, first out)
- Adding data to stack is called *pushing onto the stack* and removing data is called *popping off the stack*
- Data on stack must have known and fixed sized

** Heap
Data with unknown size at compile time or changing size must be stored on the heap. *Pointer* will point to the data on the heap. The process is called *allocating on the heap*

** Ownership model addresses:
- keeping track of what parts of code are using what data on the heap
- minimizing the amount of duplicate data on the heap
- cleaning up unused data on the heap so the system doesn't run out of  memory

** *The ownership rules*
- each value in Rust has a variable that's called its *owner*
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.
- =borrowiwng= is having references as function parameters. I can
  =borrow= mutably or immutably
- The variable is valid from the point at which it's declared until the
  end of the current scope
- Values allocated on heap have to request memory from OS at runtime, when their scope is about to finish, Rust calls =drop= automatically.
** Examples
- these values will be *copied*, because =i32= is stored on stack
#+begin_src rust
let x = 5;
let y = x;
#+end_src

- these values will be *moved*, because =String= is stored on heap
#+begin_src rust
let s1 = String::from("hello");
let s2 = s1;
#+end_src

  [[notes_assets/moving_values_stored_on_heap.svg]]

- these values (which are store on the heap) will be *copied*, because
  we use =clone= method

#+begin_src rust
let s1 = String::from("hello");
let s2 = s1.clone();
#+end_src

  [[notes_assets/coping_values_stored_on_heap.svg]]

- types which implements =Copy= trait: integers, booleans, floats,
  chars, tuples containing these types.

- ownership and functions without returns

#+begin_src rust
fn main() {
  let s = String::from("hello");  // s comes into scope
  takes_ownership(s);             // s's value moves into the function and so is no longer valid here
  let x = 5;                      // x comes into scope
  makes_copy(x);                  // x would move into the function, but i32 is Copy, so it’s okay to still use x afterward
  println!("{}", x);
  // error: value borrowed here after move
  // println!("{}", s);
} // Here, x goes out of scope, then s. But because s's value was moved, nothing special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
#+end_src

- ownership and function with return values

#+begin_src rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its value into s1
    let s2 = String::from("hello");     // s2 comes into scope
    let s3 = takes_and_gives_back(s2);  // s2 is moved takes_and_gives_back, which also moves its return value into s3
    let s4 = String::from("hello");
    let (s5, v) = calculate_length(s4);
    println!("The length of '{}' is {}.", s2, len);
    println!("{} {}", s1, s3);
    // error: value borrowed here after move
    // println!("{}", s2);
}

fn gives_ownership() -> String {  // gives_ownership will move return value into the function that calls it
    let some_string = String::from("hello"); // some_string comes into scope
    some_string    // some_string is returned and moves out to the calling function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes scope
    a_string  // a_string is returned and moves out to the calling function
}

fn calculate_length(s: String) -> (String, usize) {
  let length = s.len();
  (s, length)
}
#+end_src

** references.
*** *The rules of references*

- At any given time, you can have either one mutable reference or any number of immutable references.
- References must always be valid.
- Reference scope starts from where it is introduced and continues through the last time that reference is used.

#+begin_src rust
fn main() {
    // immutable
    let s1 = String::from("hello");
    let len = calc_len(&s1);
    println!("len of {} is {}", s1, len);

    // mutable
    let mut s = String::from("hello");
    change(&mut s);
    println!("{}", s);

    // error cannot 's' as mutable more than once
    // let r1 = &mut s;
    // let r2 = &mut s;
    // println!("{} {}", r1, r2);

    {
        let r1 = &mut s;
        println!("{}", r1);
    } // r1 goes out of scope here, so we can make a new reference with no problems.
    let r2 = &mut s;
    println!("{}", r2);
}

fn calc_len(s: &String) -> usize {
    s.len()
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
#+end_src

*** slice - a contiguous sequence of elements in a collection

#+begin_src rust
let s = String::from("hello world");
let hello = &s[0..5];
let world = &s[6..11];
let orld = &s[7..];
let hell = &s[..4];
let helloworld = &s[..];
#+end_src

* Smart Pointers
  :PROPERTIES:
  :CUSTOM_ID: ch15---smart-pointers
  :END:
A pointer is a general concept for a variable that contains an address
in memory. Reference =&= is the most common pointer in Rust.

*Smart pointers* are pointers with additional capabilities and metadata.

- Smart pointers implements Deref and Drop traits. Deref trait allows an
  instance of the smart pointer struct to behave like a reference. Drop
  trait allows you to customize the code that is run when an instance of
  the smart pointer goes out of scope.
- Additional difference between references and smart pointers is that
  references are pointers that only borrow data; in contrast, in many
  cases, smart pointers own the data they point to.
- String and Vec are both smart pointers because they own the data and
  allow to modify it. They also hold metadata (e.g. vec length) and
  guarantees (String being valid utf8)

** Custom Smart Pointer, =Dereference= and =Drop= traits
   :PROPERTIES:
   :CUSTOM_ID: custom-smart-pointer-dereference-and-drop-traits
   :END:
**** Derefernce trait
     :PROPERTIES:
     :CUSTOM_ID: derefernce-trait
     :END:

- Rust converts =y*= to =*(y.deref())=
- *[[dict:%22ukryty,domniemany%22][Implicit]] Deref
  [[dict:%22przymus,wymuszenie%22][Coercions]] with Functions and
  Methods.* Deref coercion works only on types that implement the Deref
  trait. Deref coercion converts such a type into a reference to another
  type. For example, deref coercion can convert &String to &str because
  String implements the Deref trait such that it returns str. Deref
  coercion happens automatically when we pass a reference to a
  particular type's value as an argument to a function or method that
  doesn't match the parameter type in the function or method definition.
  A sequence of calls to the deref method converts the type we provided
  into the type the parameter needs.

#+begin_src rust
  fn main() {
      let z = MyBox::new(String::from("Lola"));
      hello(&z);
      hello(&(*z));
      hello(&(*z)[..]);
  }

  fn hello(name: &str) {
      println!("{}", name);
  }
#+end_src

Above will print =Lola= three times, bacause rust is able to call Deref
until it matches parameter's type. This is resolved during compliation.

- How Deref Coercion Interacts with Mutability

  - From =&T= to =&U= when =T=: =Deref<Target=U>=
  - From =&mut= =T= to =&mut U= when =T=: =DerefMut<Target=U>=
  - From =&mut= =T= to =&U= when =T=: =Deref<Target=U>=
  - From =&mut= =T= to =&U= when =T=: =Deref<Target=U>=

    - Conversion from mutable ref to immutable is possible, but that's
      not true for the opposite as it will break borrowing rules.
      Converting an immutable reference to a mutable reference would
      require that initial immutable reference is the only immutable
      reference to that data, but the borrowing rules don't guarantee
      that.

**** Drop trait
     :PROPERTIES:
     :CUSTOM_ID: drop-trait
     :END:
#+begin_src rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
#+end_src

outputs:

#+begin_src rust
CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
#+end_src

- =Drop= lets me customize what happens when a value is about to go out
  of scope, to e.g. release resource like files or network connection.

- Compiler will insert that code in a place where value is about to go
  out of scope. *As a result, you don't need to be careful about placing
  cleanup code everywhere in a program that an instance of a particular
  type is finished with---you still won't leak resources!* 🙉💛

- The =Drop= trait requires you to implement one method named =drop=
  that takes a mutable reference to =self=

- Variables are dropped in reverse order of their creation

- =Drop= trait is in the prelude, so I don't need to bring it into scope

- it's not straightforward to disable the automatic =drop= functionality

- to manually drop a value, I need to call =std::mem::drop=, which is
  already in the scope under =drop()=

** Most common smart pointers in std:
   :PROPERTIES:
   :CUSTOM_ID: most-common-smart-pointers-in-std
   :END:
**** =Box<T>= for allocating values in the heap.
     :PROPERTIES:
     :CUSTOM_ID: boxt-for-allocating-values-in-the-heap.
     :END:
#+begin_src rust
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, Box<List>),
    Nil
}

fn main() {
    let b = Box::new(5);
    let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));

    println!("b = {}", b);
    println!("{:?}",list);
}
#+end_src

--------------

#+begin_src rust
fn main() {
  let x = 5;
  let y = Box::new(x);

  assert_eq!(5, x);
  assert_eq!(5, *y);
}
#+end_src

- Box points to a value on the heap.

- Boxes don't have performance overhead other than storing their data on
  the heap.

  Usage examples:

  - When I have a type whose size can't be known at compile time and I
    want to use a value of that type in a context that requires an exact
    size.
  - When I have a large amount of data and I want to transfer ownership
    but ensure the data won't be copied when coping
  - When I want to own a value and I care only that it's a type that
    implements a particular trait rather than being specific type

**** =Rc<T>= a reference counting type that enables multiple ownership
     :PROPERTIES:
     :CUSTOM_ID: rct-a-reference-counting-type-that-enables-multiple-ownership
     :END:
#+begin_src rust
  enum List {
      Cons(i32, Rc<List>),
      Nil,
  }

  use crate::List::{Cons, Nil};
  use std::rc::Rc;

  fn main() {
      let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
      let b = Cons(3, Rc::clone(&a));
      let c = Cons(4, Rc::clone(&a));
  }
#+end_src
** Smartpointer Reference Count
[[notes_assets/smartpointer_referencecount.svg]]
#+begin_src rust
fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!("count after creating a = {}", Rc::strong_count(&a));
    let b = Cons(3, Rc::clone(&a));
    println!("count after creating b = {}", Rc::strong_count(&a));
    {
        let c = Cons(4, Rc::clone(&a));
        println!("count after creating c = {}", Rc::strong_count(&a));
    }
    println!("count after c goes out of scope = {}", Rc::strong_count(&a));
}
#+end_src

output
#+begin_src rust
count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
#+end_src

- The =Rc<T>= type keeps track of the number of references to a value
  which determines whether or not a value is still in use.
- If there are zero references to a value, the value can be cleaned up
  without any references becoming invalid.
- Use the =Rc<T>= type when we want to allocate some data on the heap
  for multiple parts of our program to read and we can't determine at
  compile time which part will finish using the data last.
- If I knew which part would finish last, we could just make that part
  the data's owner, and the normal ownership rules enforced at compile
  time would take effect.
- =Rc<T>= is only for use in single-threaded scenarios.
- Use =Rc::clone(&a)= instead of =a.clone()= because implementation of
  =Rc::clone= doesn't make a deep copy of all the data like most types'
  implementations of clone do. The call to =Rc::clone= only increments
  the reference count, which doesn't take much time.
- Via immutable references, =Rc<T>= allows me to share data between
  multiple parts of your program for reading only. If =Rc<T>= allowed to
  have multiple mutable references, it would violate one of the
  borrowing rules discussed in Chapter 4: multiple mutable borrows to
  the same place can cause data races and inconsistencies.
- =strong_count=

  - when count is 0, the value is cleaned up
  - represents ownership relationship

- =weak_count=

  - can be created by calling =Rc:downgrade(&Rc<T>)=, it creates
    instance of type =Weak<T>=
  - they don't express ownership relationship
  - =Rc<T>= type uses =weak_count= to keep track how many =Weak<T>=
    references exist
  - Doesn't have to be 0 for the =Rc<T>= to be cleaned up
  - The value that =Weak<T>= references to might'ev been dropped,
    therefore:

    - To do anything with the referenced value I must make sure it's
      valid
    - To do this, I call =upgrade= method on =Weak<T>= instance, which
      returns =Option<Rc<T>>= (=Some= if value hasn't been dropped,
      =None= if it had been dropped). Rust will ensure =Some=/=None=
      cases are handled, hence no invalid pointer.

**** =Ref<T>= and =RefMut<T>=, accessed via =RefCell<T>=
     :PROPERTIES:
     :CUSTOM_ID: reft-and-refmutt-accessed-via-refcellt
     :END:
#+begin_src rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));
    println!("a before = {:?}", a);

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
#+end_src

outputs

#+begin_src rust
a before = Cons(RefCell { value: 5 }, Nil)
a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
#+end_src

- Type that enforces the borrowing rules at runtime instead at compile
  time.
- Interior mutability is a design pattern that allows to mutate data
  even when there are immutable references to that data (normally
  disallowed by borrowing rules)
- =RefCell<T>= represents single ownership over the data in holds.
- The program will =panic= if I break borrowing rules (more than one
  mutable reference, or invalid reference)
- =RefCell<T>= is useful when I'm sure the code follows the borrowing
  rules but the compiler is unable to understand and guarantee that
- =RefCell<T>= is only for use in single-threaded scenarios, and will
  give a compile-time error when used in in multithreaded context
- Because =RefCell<T>= allows mutable borrows checked at runtime, I can
  mutate the value inside the =RefCell<T>= even when the RefCell is
  immutable.
-

**** =Cell<T>=
** Memory leaks
   :PROPERTIES:
   :CUSTOM_ID: memory-leaks
   :END:

- Memory leak is created when e.g. reference count of each item in the
  cycle will never reach 0, and the values will never be dropped, e.g.

#+begin_src rust
use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell<Rc<List>>),
    Nil,
}

impl List {
    fn tail(&self) -> Option<&RefCell<Rc<List>>> {
        match self {
            Cons(_, item) => Some(item),
            Nil => None,
        }
    }
}
#+end_src

  #+caption: alt text
  [[notes_assets/smartpointer_cyclereferencememoryleak.svg]]

- Preventing memory leaks entirely is not one of Rust's guarantees

- In *tree* data structure parent owns it's children (when we drop
  parent, children are dropped with it), and the child is aware of it's
  parent but doesn't own it. It would be easy to create reference cycle
  if I were to use =parent: RefCell<Rc<Node>>=, but thanks to =Weak<T>=
  I'm able to solve this issue in a safe manner.

#+begin_src rust
use std::rc::{Weak, Rc};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell<Weak<Node>>,
    children: RefCell<Vec<Rc<Node>>>,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!("leaf parent = {:?}, strong = {}, weak = {}",
        leaf.parent.borrow().upgrade(),
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );
    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);

        println!(
            "branch strong = {}, weak = {}",
            Rc::strong_count(&branch),
            Rc::weak_count(&branch),
        );

        println!(
            "leaf strong = {}, weak = {}",
            Rc::strong_count(&leaf),
            Rc::weak_count(&leaf),
        );

        println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
        // println!("{:?}, {:?}, {:?}",
            // branch,
            // branch.children,
            // leaf.parent.borrow().upgrade());
    }

    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());
    println!(
        "leaf strong = {}, weak = {}",
        Rc::strong_count(&leaf),
        Rc::weak_count(&leaf),
    );

}
#+end_src

** COMMENT CODE EXAMPLES
*** mutable reference to immutable variable
#+begin_src rust :exports both
fn main() {
    let x = 5;
    let y = &mut x;
    ,*y = 8;
}
#+end_src

#+RESULTS:
: error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable

*** immutable reference to mutable variable
#+begin_src rust :exports both
fn main() {
    let mut x = 5;
    let y = &x;
    *y = 8;
}
#+end_src

#+RESULTS:
: error[E0594]: cannot assign to `*y`, which is behind a `&` reference
: |     let y = &x;
: |             -- help: consider changing this to be a mutable reference: `&mut x`
: |     *y = 8;
: |     ^^^^^^ `y` is a `&` reference, so the data it refers to cannot be written

*** borrow checker computes lifetime
allowing for something that wouldn't be allowed if lifetimes weren't a thing
(having immutable reference and simoutenously mutating value behind the smart pointer)
#+begin_src rust :exports both
fn main() {
    let rand = 0.5;
    let mut x = Box::new(42);
    let r = &x;           // 'a
    if rand > 0.5 {
        *x = 84;
    } else {
        println!("{}", r);  // 'a
    }
    // the compiler is smart enough to figure the flow of computation can
    // go either of two ways:
    // 1. dereferece x and assign value to it (and simoutenously (and quietly)
    //    disregards the fact there is a immutable reference `r` in the scope)
    // 2. read value behind immutable reference r (and disregard line of code
    //    which tries to dereference and modify x, despite the fact immutable
    //    reference has been already declared in the scope)

    // uncommenting below line --
    // println!("{}", r);
    // -- will result in a following error
    //     error[E0506]: cannot assign to `*x` because it is borrowed
    //   --> src/main.rs:7:9
    //    |
    // 5  |     let r = &x;           // 'a
    //    |             -- borrow of `*x` occurs here
    // 6  |     if rand > 0.5 {
    // 7  |         *x = 84;
    //    |         ^^^^^^^ assignment to borrowed `*x` occurs here
    // ...
    // 11 |     println!("{}", r);  // 'a
    //    |                    - borrow later used here
}
#+end_src

**** another example
#+begin_src rust :exports both
fn main() {
    let mut x = Box::new(42);
                            //     first iteration       | second iteration      | ...
    let mut z = &x;         // 1   lifetime 'a - created
    for i in 0..3 {
        println!("{}", z);  // 2   lifetime 'a - checked,  lifetime 'b - checked
        x = Box::new(i);    // 3   lifetime 'a - deleted,  lifetime 'b - deleted
        z = &x;             // 4   lifetime 'b - created,  lifetime 'c - created
    }
    println!("{}", z);
}
#+end_src

#+RESULTS:
: 42
: 0
: 1
: 2
*** generic lifetimes
#+begin_src rust
struct StrSplit<'s, 'p> {
  delimiter: &'p str,
  document: &'s str,
}

impl<'s, 'p> Iterator for StrSplit<'s, 'p> {
  type Item = &'s str;
  fn next(&mut self) -> Option<Self::Item> {
    self.document.split(self.delimiter).next()
}}

fn main() {
    let mut a = "ast,ars";
    let d = ",";
    let mut x = StrSplit{delimiter: &d, document:&a};
    a = "ff,ff";
    for i in x.next() {println!("{}", i);}
    println!("{}", a);
}
#+end_src

#+RESULTS:
: ast
: ff,ff
*** lifetime variance
#+begin_src rust :exports both
struct MutStr<'a, 'b> { s: &'a mut &'b str }
// below will also work, since both "hello" an "world" are 'static
// struct MutStr<'a> { s: &'a mut &'static str }

// if two lifetimes are replaced with a single 'a, the code fails to compile --
// struct MutStr<'a> { s: &'a mut &'a str }
// -- that's because, the compiler will infer that string "hello" and "world"
// are 'static, therefore the compiler will do sth like this:
// struct MutStr { s: &'static mut &'static str }
// which will not fly, because in `main` the code tries to modify the reference
// but it is unable to do so since it was marked as 'static
// aka: 'static and mut can't work together ... UNLESS,
// the value would never be accessed again
// fn main() {
//     let mut s = "hello";
//     *MutStr { s: &mut s }.s = "world";
//     no println here.....
// }
// the real reason why we can't println `s` later is:
// lifetime variance incompability -- &mut T is invariant in T, therefore
// compiler is unable to shortend mutable borrow

// we could however do --
// struct MutStr { s: &'static &'static str }
// -- but this would force us to write:
// fn main() {
//     MutStr { s: &"hello" };
// }
// which defeats whole purpose

fn main() {
    let mut s = "hello";
    ,*MutStr { s: &mut s }.s = "world";
    println!("{}", s);
}
#+end_src

#+RESULTS:
: world

* Generics Types, Traits and Lifetimes
  :PROPERTIES:
  :CUSTOM_ID: ch10---generics-types-traits-and-lifetimes
  :END:
#+begin_src rust
use std::fmt::Display;

fn longest_with_an_announcement<'a, T>(x: &'a str, y: &'a str, ann: T) -> &'a str
    where T: Display
{
    println!("Announcement! {}", ann);
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
#+end_src
** Traits
   :PROPERTIES:
   :CUSTOM_ID: traits
   :END:
- *A type's behavior consists of the methods we can call on that type. Different types share the same behavior if we can call the same methods on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.*
- A trait tells the Rust compiler about functionality a particular type has and can share with other types.
- Use traits to define shared behavior in an abstract way.
- Use trait bounds to specify that a generic can be any type that
  has certain behavior.
- One restriction to note with trait implementations is that we can implement a trait on a type only if either the trait or the type is local to our crate. I can't implement external traits on external types, e.g. implement the =Display= trait on =Vec<T>= within our =aggregator= crate, because =Display= and =Vec<T>= are defined in the standard library and aren't local to our =aggregator= crate.
  - This restriction is part of a property of programs called *[[id:2aaf6cbb-71b0-470b-bdac-75573f61d481][coherence]]*, and more specifically the [[id:33360f2f-4c61-4085-87c6-3a8fae37aedf][orphan rule]], so named because the parent type is not present
  - Without the rule, two crates could implement the same trait for the same type, and Rust wouldn't know which implementation to use.
- =Trait= has to be public (=pub=) in order to implement it in other crates

*** Example
#+begin_src rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

pub trait Summary {
    fn summarize(&self) -> String;
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}

impl Summary for Tweet {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.username, self.content, self.reply)
    }
}

fn main() {
    let tweet = Tweet {
        username: String::from("horse_ebooks"),
        content: String::from("of course, as you probably already know, people"),
        reply: false,
        retweet: false,
    };

    println!("1 new tweet: {}", tweet.summarize());
}
#+end_src

*** *Default implementation*

**** basic
#+begin_src rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
#+end_src

**** nested requirements
#+begin_src rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
// To use this version of Summary, we only need to define summarize_author when we implement the trait on a type:
impl Summary for Tweet {
    fn summarize_author(&self) -> String {
        format!("@{}", self.username)
    }
}
#+end_src

- ??? Note that it isn't possible to call the default implementation from an overriding implementation of that same method.

*** *Trait as parameters*

**** =impl Trait= sugar syntax
#+begin_src rust
pub fn notify(item: impl Summary) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

**** trait bound
#+begin_src rust
pub fn notify<T: Summary>(item: T) {
    println!("Breaking news! {}", item.summarize());
}
#+end_src

- useful in more complex situations, e.g.:
#+begin_src rust
pub fn notify(item1: impl Summary, item2: impl Summary) {}
// is equal to
pub fn notify<T: Summary>(item1: T, item2: T) {}
#+end_src

- multiple trait bounds with =+= syntax
#+begin_src rust
pub fn notify(item: impl Summary + Display) {}
// or
pub fn notify<T: Summary + Display>(item: T) {}
#+end_src

- trait bound using =where= clause
#+begin_src rust
fn some_function<T: Display + Clone, U: Clone + Debug>(t: T, u: U) -> i32 {
// or less clustered using where clause
fn some_function<T, U>(t: T, u: U) -> i32
  where T: Display + Clone,
        U: Clone + Debug
{
#+end_src

- returning types which implement traits, *however this only works in functions which return single type, see CH1702 ???*
#+begin_src rust
fn returns_summarizable() -> impl Summary {
  Tweet {
      username: String::from("horse_ebooks"),
      content: String::from("of course, as you probably already know, people"),
      reply: false,
      retweet: false,
  }
}
#+end_src

*** *trait objects* (CH17)
Trait object points to both an instance of a type implementing specified trait as well as a table used to look up trait methods on that type at runtime; they purpose is to allow abstraction across common behavior. They can be created by specifying some sort of pointer (e.g. =&= or =Box<T>=) + =dyn= keyword + relevant =trait=. They can be used in place of generic or concrete type. *Rust's type system will ensure at compile time that any value used in that context will implement the trait object's trait, therefore, it doesn't need to know all the possible types at compile time.* When I use *trait objects* Rust must use *dynamic dispatch*, it comes with runtime cost (a cost of pointers lookup). Dynamic dispatch also prevents the compiler from choosing to inline a method's code, which in turn prevents some optimizations ???. Object safety is required for Trait Objects: the return type isn't =Self=, and there are no generic type parameters???.

#+begin_src rust
pub trait Draw {
    fn draw(&self);
}

pub struct Screen {
    pub components: Vec<Box<dyn Draw>>,
}
impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
// vs.:
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}
impl<T> Screen<T>
    where T: Draw {
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
// which limits `Screen` struct to have list of components all of the same type
#+end_src

*** *Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name* (CH19)

#+begin_src rust
trait Pilot {
    fn fly(&self);
}

trait Wizard {
    fn fly(&self);
}

struct Human;

impl Pilot for Human {
    fn fly(&self) {
        println!("This is your captain speaking.");
    }
}

impl Wizard for Human {
    fn fly(&self) {
        println!("Up!");
    }
}

impl Human {
    fn fly(&self) {
        println!("*waving arms furiously*");
    }
}

fn main() {
    let person = Human;
    Pilot::fly(&person);
    Wizard::fly(&person);
    person.fly();
}
#+end_src

*** *Using Supertraits to Require One Trait's Functionality Within Another Trait.* (CH19)
Sometimes, you might need one trait to use another trait's functionality. In this case, you need to rely on the dependent trait also being implemented. The trait you rely on is a supertrait of the trait you're implementing.

#+begin_src rust
use std::fmt;

fn main() {
  let p = Point {x:1, y:2};
  p.outline_print();
}

struct Point {
    x: i32,
    y: i32,
}

use std::fmt;

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "({}, {})", self.x, self.y)
    }
}

trait OutlinePrint: fmt::Display {
    fn outline_print(&self) {
        let output = self.to_string();
        let len = output.len();
        println!("{}", "*".repeat(len + 4));
        println!("*{}*", " ".repeat(len + 2));
        println!("* {} *", output);
        println!("*{}*", " ".repeat(len + 2));
        println!("{}", "*".repeat(len + 4));
    }
}

impl OutlinePrint for Point {}
#+end_src

*** *Using the Newtype Pattern to Implement External Traits on External Types.* (CH19)
To get around orphan rule restriction, it's possible to use *newtype pattern*, where I wrap External Type with a tuple, to implement External Trait on that tuple. There is no runtime  performance penalty. The downside is the fact that new type doesn't have methods of the value it's holding, although implementing =Deref= trait would be a solution.

  #+begin_src rust
    use std::fmt;

    struct Wrapper(Vec<String>);

    impl fmt::Display for Wrapper {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            write!(f, "[{}]", self.0.join(", "))
        }
    }

    fn main() {
        let w = Wrapper(vec![String::from("hello"), String::from("world")]);
        println!("w = {}", w);
    }
  #+end_src
*** why some traits have associated type insted of generics
e.g. why
#+begin_src rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>
}
#+end_src
instead of this
#+begin_src rust
trait Iterator<Item> {
    fn next(&mut self) -> Option<Item>;
}
#+end_src

Use associated type if we expect there will be only one implementation of the trait for a given type.

* Functional Language Features: Iterators and Closures
#+begin_src rust
struct Counter {
      count: u32,
  }

  impl Counter {
      fn new() -> Counter {
          Counter { count: 0 }
      }
  }

  impl Iterator for Counter {
      type Item = u32;

      fn next(&mut self) -> Option<Self::Item> {
          self.count += 1;

          if self.count < 6 {
              Some(self.count)
          } else {
              None
          }
      }
  }

  #[test]
  fn calling_next_directly() {
      let mut counter = Counter::new();

      assert_eq!(counter.next(), Some(1));
      assert_eq!(counter.next(), Some(2));
      assert_eq!(counter.next(), Some(3));
      assert_eq!(counter.next(), Some(4));
      assert_eq!(counter.next(), Some(5));
      assert_eq!(counter.next(), None);
  }

  #[test]
  fn using_other_iterator_trait_methods() {
      let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                   .map(|(a, b)| a * b)
                                   .filter(|x| x % 3 == 0)
                                   .sum();
      assert_eq!(18, sum);
  }
#+end_src

** closures
- closures are anonymous function that can be stored in a variable, passed as argument to other functions
- unlike functions, they can capture values from the scope in which they're defined
*** capturing environment values
Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter:
- taking ownership
- borrowing mutably
- borrowing immutably.

These are encoded in the three Fn traits as follows:
- =FnOnce= consumes the variables it captures from its enclosing scope, known as the closure's environment. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The Once part of the name represents the fact that the closure can't take ownership of the same variables more than once, so it can be called only once.
- =FnMut= can change the environment because it mutably borrows values.
- =Fn= borrows values from the environment immutably.

- If one wants to force the closure to take ownership of the values it uses in the environment, use =move= keyword before the parameter list. This technique is mostly useful when passing a closure to a new thread to move the data so it's owned by the new thread.
**** COMMENT example
#+begin_src rust
struct Abc<T> where T: FnMut(u8) -> bool
{
    f: T
}

#[derive(Debug)]
struct Def<T> where T: FnOnce(u8) -> bool
{
    f: T
}

struct Ghj<T> where T: Fn(u8) -> bool
{
    f: T
}


fn main() {
    // move
    let x = vec![1, 2, 3];
    let equal_to_x = move |z| z == x;
    // println!("can't use x here: {:?}", x);
    // Error: borrow of moved value: `x`
    // | let x = vec![1, 2, 3];
    // |     - move occurs because `x` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
    // | let equal_to_x = move |z| z == x;
    // |                  --------      - variable moved due to use in closure
    // |                  |
    // |                  value moved into closure here
    // | println!("can't use x here: {:?}", x);
    // |                                    ^ value borrowed here after move
    let y = vec![1, 2, 3];
    assert!(equal_to_x(y));
    // assert!(equal_to_x(y));
    // Error: use of moved value: `y`
    // | let y = vec![1, 2, 3];
    // |     - move occurs because `y` has type `std::vec::Vec<i32>`, which does not implement the `Copy` trait
    // | assert!(equal_to_x(y));
    // |                    - value moved here
    // | assert!(equal_to_x(y));
    // |                    ^ value used here after move
    let e = vec![1, 2, 3];
    assert!(equal_to_x(e));

    // FnMut
    let mut y = 5;
    let mut x = Abc {
        f: |x| {
            y = 3;
            x == y
        }
    };
    assert_eq!((x.f)(3), true);
    assert_eq!((x.f)(3), true);

    // FnOnce
    let mut i = 4;
    let o = Def {
        f: |x| {
            i = 3;
            x == i
        }
    };
    assert_eq!((o.f)(3), true);
    // assert_eq!((o.f)(3), true);
    // Error: use of moved value: `o.f`
    // 38 |     assert_eq!((o.f)(3), true);
    //    |                ----- value moved here
    // 39 |     assert_eq!((o.f)(3), true);
    //    |                ^^^^^ value used here after move
    // = note: move occurs because `o.f` has type i:&mut u8, which does not implement the `Copy` trait
    assert_eq!(i, 3);

    // Fn
    let q = 5;
    let w = Ghj {
        f: |x| {
            // q = 3;
            // Error: cannot assign to `q`, as it is a captured variable in a `Fn` closure
            // help: consider changing this to accept closures that implement `FnMut`
            x == q
        }
    };
    assert_ne!((w.f)(3), true);
    assert_ne!((w.f)(3), true);
}
#+end_src

*** COMMENT Example (sugar) syntax
#+begin_src rust
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
#+end_src
*** COMMENT returning closures
#+begin_src rust
fn returns_closure() -> Box<dyn Fn(i32) -> i32> {
    Box::new(|x| x + 1)
}
#+end_src
*** COMMENT inline closure
#+begin_src rust
let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();

let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec<String> = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();

enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec<Status> =
    (0u32..20)
    .map(Status::Value)
    .collect();
#+end_src
** iterators
- =.iter()= - produces iterator over immutable references
- =.iter_mut()= - produces iterator over mutable references
- =.into_iter()= - produces iterator over owned values
*** =for v in vs {}= vs =for v in vs.iter {}=
this one will consume vs, and give owned v
#+begin_src rust
let vs = vec![1,2,3];
for v in vs {
    // consumes vs, owned v
}
#+end_src
this one will borrow vs, and give & to v
#+begin_src rust
let vs = vec![1,2,3];
for v in &vs {
    // consumes vs, owned v
}
#+end_src
this one will borrow vs, and give & to v
#+begin_src rust
let vs = vec![1,2,3];
for v in vs {
    // consumes vs, owned v
}
#+end_src
*** slow RangeInclusive
https://github.com/rust-lang/rust/issues?q=is:issue+is:open+RangeInclusive+label:I-slow

*** COMMENT example
#+begin_src rust
let v1 = vec![1, 2, 3];
let v1_iter = v1.iter();
for val in v1_iter {
    println!("Got: {}", val);
}
#+end_src
*** COMMENT another example
#+begin_src rust
let v1 = vec![1, 2];
let mut v1_iter = v1.iter();
assert_eq!(v1_iter.next(), Some(&1));
assert_eq!(v1_iter.next(), Some(&2));
assert_eq!(v1_iter.next(), None);
#+end_src
*** COMMENT implementing iterator on custom type
#+begin_src rust
pub trait Iterator {
    type Item;

    fn next(&mut self) -> Option<Self::Item>;

    // methods with default implementations elided
}
#+end_src
*** COMMENT iterators also can be returned from functions
#+begin_src rust
pub fn move_targets_from(&self) -> impl Iterator<Item = Coordinate> {
   let mut moves = Vec::new();
   let Coordinate(x, y) = *self;

   if y >= 1 {
      moves.push(Coordinate(x + 1, y - 1));
   }
   // probably bug
   moves.push(Coordinate(x + 1, y + 1));
   if x >= 1 && y >= 1 {
      moves.push(Coordinate(x - 1, y - 1));
   }
   if x >= 1 {
      moves.push(Coordinate(x - 1, y + 1));
   }
   moves.into_iter()
}
#+end_src
*** COMMENT iterator with itertools
#+begin_src rust
use itertools::Itertools;

type U8Iter4 = impl Iterator<Item=(u8, u8, u8, u8)>;

fn make_iter() -> U8Iter4 {
    iproduct!(0..=255u8, 0..=255u8, 0..=255u8, 0..=255u8)
}

pub struct Thing(U8Iter4);
impl Thing {
    pub fn new() -> Self {
        Thing(make_iter())
    }
    pub fn next_u8x4(&mut self) -> Option<[u8; 4]> {
        self.0.next().map(|(a, b, c, d)| [a, b, c, d])
    }
}
#+end_src
*** COMMENT iterator
#+begin_src rust
type U32Iter = impl Iterator<Item=u32>;

fn make_iter() -> U32Iter {
    0 ..= u32::max_value()
}

pub struct Thing(U32Iter);
impl Thing {
    pub fn new() -> Self {
        Thing(make_iter())
    }
    pub fn next_u8x4(&mut self) -> Option<[u8; 4]> {
        self.0.next().map(|n| n.to_be_bytes())
    }
}
#+end_src
* Types
** type synonyms with type aliases
#+begin_src rust
type Kilometers = i32;
let x: i32 = 5;
let y: Kilometers = 5;
#+end_src

#+begin_src rust
type Thunk = Box<dyn Fn() + Send + 'static>;

let f: Thunk = Box::new(|| println!("hi"));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -> Thunk {
    // --snip--
}
#+end_src

#+begin_src rust
use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize, Error>;
    fn flush(&mut self) -> Result<(), Error>;
    fn write_all(&mut self, buf: &[u8]) -> Result<(), Error>;
    fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<(), Error>;
}

// VS

type Result<T> = std::result::Result<T, std::io::Error>;
pub trait Write {
    fn write(&mut self, buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    fn write_all(&mut self, buf: &[u8]) -> Result<()>;
    fn write_fmt(&mut self, fmt: Arguments) -> Result<()>;
}
#+end_src

** TODO never type
#+begin_src rust
()
#+end_src

** TODO Dynamically Sized Types and the Sized Trait
#+begin_src rust

#+end_src

** Type alias =type X = impl Trait;=
 - [[https://github.com/rust-lang/rfcs/blob/master/text/2515-type_alias_impl_trait.md][RFC]]
